require 'rubygems'
gem 'gruff'
require 'gruff'

class Problem
  @@instances = [ ]
  def self.instances
    @@instances
  end

  def self.instances_enabled
    instances.select{|x| x.enabled }
  end

  attr_accessor :name, :description, :example, :n, :init, :setup, :around, :enabled
  attr_accessor :inline
  attr_accessor :solutions, :measurements
  attr_accessor :synopsis, :notes

  attr_accessor :show_solution_graphs, :show_platform_graphs

  def initialize name
    @name = name
    @n = [ 100000 ]
    @measurements = [ ]
    @solutions = [ ]
    @init = ''
    @setup = ''
    @around = '__SOLUTION__'
    @enabled = (ENV['ENABLED'] || 1).to_i != 0
    @show_solution_graphs = true
    @show_platform_graphs = false
    @@instances << self
  end

  def solution name, code
    sol = Solution.new(name, code)
    @solutions << sol 
    sol.index = @solutions.size
    sol.problem = self
    sol
  end

  def measurement_file plat = nil
    if plat
      "measurement/#{self.name}-#{plat.name}.rb"
    else
      @measurement_file ||=
        "measurement/#{self.name}.rb".freeze
    end
  end
  
  def output_file plat = nil
    if plat
      "measurement/#{self.name}-#{plat.name}.txt"
    else
      @measurement_file ||=
        "measurement/#{self.name}.txt".freeze
    end
  end

  def measure!
    return self unless @enabled

    prob = self

    unless ENV['FORCE']
      if File.exist?(output_file)
        $stdout.puts "#{output_file} already exists, use FORCE=1 to force"
        return self
      end
    end
    File.unlink(output_file) rescue nil

    render
    
    $stdout.puts "\n\n==============================================================="
    $stdout.puts "Problem: #{prob.name}\n"

    platforms.each do | plat |
      plat.exec! prob
    end
    cmd = "cat #{platforms.map{|plat| output_file(plat)} * " "} > #{output_file}"
    system(cmd) or raise "ERROR: #{cmd}"
    
    self
  end

  def platforms
    @platforms ||=
      begin
        filter = (ENV['PLATFORM'] || '').split(/\s*,\s*|\s+/)
        filter = nil if filter.empty?
        
        Platform.instances_enabled.select do | plat |
           filter ? filter.include?(plat.name) : true
        end
      end
  end

  def problem_file
    @problem_file ||=
      "problem/#{self.name}.rb"
  end

  # Kernel.rand(Date.today.to_s)
  @@srand ||= Kernel.rand(1 << 24)

  def render file = nil
    file ||= problem_file
    prob = self

    File.open(file, "w+") do | fh |
      fh.puts <<"END"
#!/usr/bin/env ruby
# #{file} generated by #{__FILE__} at #{Time.now}

Dir.chdir(File.dirname(__FILE__) + '/..')

$: << '.' # for 1.9
require 'benchmark'

$platform_cmd_line = ENV['RCT_PLATFORM_CMD_LINE'] or raise 'RCT_PLATFORM_CMD_LINE not set'
$problem     = #{prob.name.inspect}
$platform    = ARGV[0] || 'UNKNOWN'
$result_file = ARGV[1] || (__FILE__ + '.result.rb')
$solution    = nil
$in_warmup   = false
$error       = nil
n = nil

$rfh = File.open($result_file, 'w+')
$rfh.puts "["
$pid = $$
Kernel.at_exit do
  $rfh.puts "]" if $$ == $pid
  $rfh.close
end

END

      wrap_rescue fh do

      fh.puts <<"END"
  Kernel.srand(#{@@srand})
END

      fh.puts <<"END"
  #{prob.init}
END

      if ENV['WARMUP'] != '0'
        fh.puts '  $stderr.write "warmup: "'
        fh.puts '  $in_warmup = true'
        render_prob fh
      end

      fh.puts '  $stderr.puts " GO!"'
      fh.puts '  $in_warmup = false'
      render_prob fh, :benchmark

      fh.puts <<"END"
$stderr.puts "\nFINISHED!"
END
      end

      fh.puts <<"END"
exit($error ? 1 : 0)
END

      fh.flush
    end
    self
  end

  def wrap_rescue fh
    prob = self
    fh.puts "begin"
    yield
    fh.puts <<"END"
rescue Exception => err
  $error = err
  if $in_warmup
    STDERR.write 'E'
  else 
    STDERR.puts "ERROR: \#{err.inspect}\n  \#{err.backtrace * "\n  "}"
  end
  $rfh.puts({ :platform => $platform, 
              :problem  => $problem, 
              :solution => $solution, 
              :n => n, 
              :error => err.to_s, 
              :backtrace => err.backtrace,
            }.inspect + ', ') 

end
END
  end

  def render_prob fh, bm = false
    prob = self
    fh.puts "Benchmark.bm(40) do | bm |" if bm
    prob.n.each do | n |
      fh.puts "n = #{n}"
      fh.puts '  $stderr.write n' unless bm
      wrap_rescue fh do
      fh.puts prob.setup
      prob.solutions.each do | sol |
        fh.puts "  $solution = #{sol.name.inspect}"

        fh.puts sol.before

        fh.puts "  ObjectSpace.garbage_collect"
        if bm
          fh.puts "  bmr = bm.report('n = #{'%7d' % n} : ' + #{sol.name.to_s.inspect}) do"
        else
          fh.puts '  $stderr.write "."'
        end

        fh.puts sol.code_block

        if bm
          fh.puts '  end' 
          fh.puts <<"END"
  $rfh.puts({ :platform => $platform, 
              :problem  => $problem, 
              :solution => $solution, 
              :n => n,
              :time => bmr.real,
             }.inspect + ', ')
   $rfh.flush
END
        end
      end # sol
      end
    end
    fh.puts "end" if bm
    self
  end

  def collect_measurements!
    prob = self

    @normalized_measuments = nil
    @measurements = [ ]
    Dir["measurement/#{prob.name}-*.rb"].sort.each do | result_file |
      $stderr.puts "Reading #{result_file}"
      results = Kernel.eval(File.read(result_file))
      prob.measurements.concat results if results
    end
    self
  end

  def normalized_measurements
    @normalized_measurements ||= measurements.map do |h|
      h = h.dup
      h[:solution] = solutions.find{|x| x.name == h[:solution]}
      h[:platform] = platforms.find{|x| x.name == h[:platform]}
      h
    end
  end

  def get_measurements filter = { }
    normalized_measurements.select do |h|
      ((f = filter[:n]) ? f == h[:n] : true) &&
      ((f = filter[:solution]) ? f == h[:solution] : true) &&
      ((f = filter[:platform]) ? f == h[:platform] : true)
    end
  end

  def get_errors filter = { }
    get_measurements(filter).
      select{|h| h[:error]}
  end

  def best_solution
    sc = { } # solution score
    platforms.each do | plat |
      st = { } # solution time per platform.
      get_measurements(:platform => plat).each do | h |
        sol = h[:solution]
        st[sol] ||= 0
        st[sol] += h[:time]
      end
      best_solution = solutions.find{|sol| st[sol] == st.values.min}
      sc[best_solution] ||= 0
      sc[best_solution] += 1
    end
    best_solution = solutions.find{|sol| sc[sol] == sc.values.max}
    best_solution
  end

  def graph_image obj
    case obj
    when Platform
      "image/#{self.name}-#{obj.name}.png"
    when Solution
      "image/#{self.name}-sol-#{obj.id}.png"
    else
      raise TypeError
    end
  end

  def graph!
    return self unless @enabled

    prob = self

    prob.collect_measurements!

    max_value = measurements.map{|h| h[:time] || 0}.max

    platforms.each do | plat |
    begin
      image_file = "slides/#{graph_image(plat)}"
      unless ENV["FORCE"]
        if File.exists?(image_file)
          $stderr.puts "Skipping #{image_file}, use FORCE=1"
          next
        end
      end
      File.unlink(image_file) rescue nil

      $stderr.write "Creating #{image_file}..."
      errors = false
      g = Gruff::Bar.new
      g.title = "#{prob.name} on #{plat.name}" 
      g.sort = false
      
      labels = { }
      self.n.each_with_index do | n, i |
        labels[i] = (i == 0 ? "n = #{n}" : "#{n}")
      end
      solutions.each do | sol |
        data = [ ]
        self.n.each do | n |
          h = get_measurements(:n => n, :solution => sol, :platform => plat).first
          errors = true unless h
          data << (h ? h[:time] : 0)
        end
        data_name = sol.name
        if errors ||= ! get_errors(:platform => plat, :solution => sol).empty?
          data_name += " (E!)"
        end
        g.data(data_name, data)
      end
      g.data(" ", [ 0 ] * self.n.size, '#000000') if n.size > 1
      g.minimum_value = 0
      g.maximum_value = max_value
      g.labels = labels
      g.write(image_file)
      $stderr.puts "DONE"
    rescue Exception => err
      $stderr.puts "ERROR: #{err.inspect}\n#{err.backtrace * "\n"}"
    end
    end

    solutions.each do | sol |
    begin
      image_file = "slides/#{graph_image(sol)}"
      unless ENV["FORCE"]
        if File.exists?(image_file)
          $stderr.puts "Skipping #{image_file}, use FORCE=1"
          next
        end
      end
      File.unlink(image_file) rescue nil

      $stderr.write "Creating #{image_file}..."

      g = Gruff::Bar.new
      g.title = "#{prob.name}: #{sol.name}" 
      g.sort = false
      
      labels = { }
      self.n.each_with_index do | n, i |
        labels[i] = (i == 0 ? "n = #{n}" : "#{n}")
      end
      platforms.each do | plat |
        errors = false
        data = [ ]
        self.n.each do | n |
          h = get_measurements(:n => n, :solution => sol, :platform => plat).first
          errors = true unless h
          data << (h ? h[:time] : 0)
        end
        data_name = plat.name
        if errors ||= ! get_errors(:platform => plat, :solution => sol).empty?
          data_name += " (E!)"
        end
        g.data(data_name, data)
      end
      g.data(" ", [ 0 ] * self.n.size, '#000000') if n.size > 1
      g.minimum_value = 0
      g.maximum_value = max_value
      g.labels = labels
      g.write(image_file)
      $stderr.puts "DONE"
    rescue Exception => err
      $stderr.puts "ERROR: #{err.inspect}\n#{err.backtrace * "\n"}"
    end
    end

    self
  end
end


