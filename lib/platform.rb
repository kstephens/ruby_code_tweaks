
class Platform
  # Kernel.rand(Date.today.to_s)
  @@srand ||= Kernel.rand(1 << 24)

  @@instances = [ ]
  def self.instances
    @@instances
  end

  attr_accessor :name, :cmd, :opts, :enabled
  def initialize name, cmd, opts = ''
    @name, @cmd, @opts = name, cmd, opts
    @cmd = File.expand_path(@cmd)
    @@instances << self
    @enabled = File.exist?(@cmd)
  end

  def details
    @details ||=
      `#{cmd} -v`.chomp.freeze
  end

  def exec! x, *args
    send("exec_#{x.class.name}!", x, *args);
  end

  def exec_Problem! prob
    return unless self.enabled

    plat = self

    file = "problem/#{prob.name}.rb"
    result_file = "measurement/#{prob.name}-#{self.name}.rb"
    measurement_txt = "measurement/#{prob.name}-#{plat.name}.txt"
    
    cmd = "/usr/bin/time #{self.cmd} #{self.opts} #{file} #{plat.name.inspect} #{result_file.inspect}"

    File.open(measurement_txt, "w+") do | fh |
      msg = "\n  #{name}: #{details}"
      $stdout.puts msg
      fh.puts msg

      msg = "  #{cmd}"
      $stdout.puts msg
      fh.puts msg
    end

    File.unlink(result_file) rescue nil
    File.open(file, "w+") do | fh |
      fh.puts <<"END"
#!/usr/bin/env ruby
# #{file} generated by #{__FILE__} at #{Time.now}

$: << '.' # for 1.9
require 'benchmark'

$platform    = ARGV[0] || 'UNKNOWN'
$result_file = ARGV[1] || (__FILE__ + '.result.rb')
$solution    = nil
n = nil

$rfh = File.open($result_file, 'w+')
$rfh.puts "["
Kernel.at_exit { $rfh.puts "]"; $rfh.close }

begin
  Kernel.srand(#{@@srand})

END

      if ENV['WARMUP'] != '0'
        fh.puts '  $stderr.write "warmup: "'
        render_prob fh, prob
      end

      fh.puts '  $stderr.puts " GO!"'
      render_prob fh, prob, :benchmark

      fh.puts <<"END"

$stderr.puts "\nFINISHED!"

rescue Exception => err
  $rfh.puts({ :platform => $platform, 
              :problem => #{prob.name.inspect}, 
              :solution => $solution, 
              :n => n, 
              :error => err.to_s, 
              :backtrace => err.backtrace,
            }.inspect + ', ') 
end
exit 0
END
      fh.flush
    end
    # system("cat #{file}")

    cmd = "( #{cmd} ) 2>&1 | tee -a #{measurement_txt}"
    unless result = system(cmd)
      data = File.read(result_file) rescue nil
      data ||= '[ ]'
      data = Kernel.eval(data) || [ ]
      data << { :platform => plat.name, :error => "#{cmd} failed", :result => result.to_s }
      File.open(result_file, "w+") do | fh |
        fh.puts(data.inspect)
      end
    end
    self
  end

  def render_prob fh, prob, bm = false
    prob.render_prob fh, bm
  end
end


